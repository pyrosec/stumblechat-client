import { EnhancedEventEmitter } from "./events";
export declare class Producer extends EnhancedEventEmitter {
    _id: any;
    _localId: any;
    _rtpSender: any;
    _track: any;
    _kind: any;
    _rtpParameters: any;
    _paused: any;
    _maxSpatialLayer: any;
    _stopTracks: any;
    _disableTrackOnPause: any;
    _zeroRtpOnPause: any;
    _appData: any;
    _closed: any;
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }: {
        id: any;
        localId: any;
        rtpSender: any;
        track: any;
        rtpParameters: any;
        stopTracks: any;
        disableTrackOnPause: any;
        zeroRtpOnPause: any;
        appData: any;
    });
    get id(): any;
    get localId(): any;
    get closed(): any;
    get kind(): any;
    get rtpSender(): any;
    get track(): any;
    get rtpParameters(): any;
    get paused(): any;
    get maxSpatialLayer(): any;
    get appData(): any;
    set appData(appData: any);
    close(): void;
    transportClosed(): void;
    getStats(): Promise<unknown>;
    pause(): void;
    resume(): void;
    replaceTrack({ track }: {
        track: any;
    }): Promise<void>;
    setMaxSpatialLayer(spatialLayer: any): Promise<void>;
    setRtpEncodingParameters(params: any): Promise<void>;
    _onTrackEnded(): void;
    _handleTrack(): void;
    _destroyTrack(): void;
}
export declare class Consumer extends EnhancedEventEmitter {
    _id: any;
    _localId: any;
    _producerId: any;
    _rtpReceiver: any;
    _paused: any;
    _appData: any;
    _track: any;
    _closed: any;
    _rtpParameters: any;
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData, }: {
        id: any;
        localId: any;
        producerId: any;
        rtpReceiver: any;
        track: any;
        rtpParameters: any;
        appData: any;
    });
    get id(): any;
    get localId(): any;
    get producerId(): any;
    get closed(): any;
    get kind(): any;
    get rtpReceiver(): any;
    get track(): any;
    get rtpParameters(): any;
    get paused(): any;
    get appData(): any;
    set appData(appData: any);
    close(): void;
    transportClosed(): void;
    getStats(): Promise<unknown>;
    pause(): void;
    resume(): void;
    _onTrackEnded(): void;
    _handleTrack(): void;
    _destroyTrack(): void;
}
export declare class DataProducer extends EnhancedEventEmitter {
    _dataChannel: any;
    _id: any;
    _sctpStreamParameters: any;
    _appData: any;
    _closed: any;
    constructor({ id, dataChannel, sctpStreamParameters, appData }: {
        id: any;
        dataChannel: any;
        sctpStreamParameters: any;
        appData: any;
    });
    get id(): any;
    get closed(): any;
    get sctpStreamParameters(): any;
    get readyState(): any;
    get label(): any;
    get protocol(): any;
    get bufferedAmount(): any;
    get bufferedAmountLowThreshold(): any;
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold: any);
    get appData(): any;
    set appData(appData: any);
    close(): void;
    transportClosed(): void;
    send(data: any): void;
    _handleDataChannel(): void;
}
export declare class DataConsumer extends EnhancedEventEmitter {
    _data: any;
    _dataChannel: any;
    _closed: any;
    _appData: any;
    _sctpStreamParameters: any;
    _id: any;
    _dataProducerId: any;
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData, }: {
        id: any;
        dataProducerId: any;
        dataChannel: any;
        sctpStreamParameters: any;
        appData: any;
    });
    get id(): any;
    get dataProducerId(): any;
    get closed(): any;
    get sctpStreamParameters(): any;
    get readyState(): any;
    get label(): any;
    get protocol(): any;
    get binaryType(): any;
    set binaryType(binaryType: any);
    get appData(): any;
    set appData(appData: any);
    close(): void;
    transportClosed(): void;
    _handleDataChannel(): void;
}
export declare class Transport extends EnhancedEventEmitter {
    _canProduceByKind: any;
    _appData: any;
    _direction: any;
    _probatorConsumerCreated: any;
    _extendedRtpCapabilities: any;
    _connectionState: any;
    _maxSctpMessageSize: any;
    _dataConsumers: any;
    _closed: boolean;
    _awaitQueue: any;
    _consumers: any;
    _handler: any;
    _dataProducers: any;
    _producers: any;
    _id: any;
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind, }: {
        direction: any;
        id: any;
        iceParameters: any;
        iceCandidates: any;
        dtlsParameters: any;
        sctpParameters: any;
        iceServers: any;
        iceTransportPolicy: any;
        additionalSettings: any;
        proprietaryConstraints: any;
        appData: any;
        handlerFactory: any;
        extendedRtpCapabilities: any;
        canProduceByKind: any;
    });
    get id(): any;
    get closed(): boolean;
    get direction(): any;
    get handler(): any;
    get connectionState(): any;
    get appData(): any;
    set appData(appData: any);
    close(): void;
    getStats(): Promise<any>;
    restartIce({ iceParameters }: {
        iceParameters: any;
    }): Promise<any>;
    updateIceServers({ iceServers }?: any): Promise<any>;
    produce({ track, encodings, codecOptions, codec, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData, }?: any): Promise<any>;
    consume({ id, producerId, kind, rtpParameters, appData }: {
        id: any;
        producerId: any;
        kind: any;
        rtpParameters: any;
        appData?: {};
    }): Promise<any>;
    produceData({ ordered, maxPacketLifeTime, maxRetransmits, priority, label, protocol, appData, }?: any): Promise<any>;
    consumeData({ id, dataProducerId, sctpStreamParameters, label, protocol, appData, }: {
        id: any;
        dataProducerId: any;
        sctpStreamParameters: any;
        label?: string;
        protocol?: string;
        appData?: {};
    }): Promise<any>;
    _handleHandler(): void;
    _handleProducer(producer: any): void;
    _handleConsumer(consumer: any): void;
    _handleDataProducer(dataProducer: any): void;
    _handleDataConsumer(dataConsumer: any): void;
}
